<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>微服务 on Coder2z Blog</title>
    <link>http://myxy99.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
    <description>Recent content in 微服务 on Coder2z Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 24 Jul 2020 14:06:27 +0800</lastBuildDate><atom:link href="http://myxy99.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>go-micro开发微服务聊天室</title>
      <link>http://myxy99.cn/posts/go-micro%E5%BC%80%E5%8F%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%81%8A%E5%A4%A9%E5%AE%A4/</link>
      <pubDate>Fri, 24 Jul 2020 14:06:27 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/go-micro%E5%BC%80%E5%8F%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%81%8A%E5%A4%A9%E5%AE%A4/</guid>
      <description>基于go-micro开发的微服务聊天室 技术栈  微服务框架：go-micro
  web框架：gin
  orm:gorm</description>
    </item>
    
    <item>
      <title>Protobuf通信协议</title>
      <link>http://myxy99.cn/posts/protobuf%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Sun, 12 Jul 2020 15:52:44 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/protobuf%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</guid>
      <description>RPC的调用过程 一个正常的RPC过程可以分为一下几个步骤：
 client调用client stub，这是一次本地过程调用。 client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做marshalling。 client所在的系统将消息发送给server。 server的的系统将收到的包传给server stub。 server stub解包得到参数。 解包也被称作 unmarshalling。 server stub调用服务过程。返回结果按照相反的步骤传给client。  在上述的步骤实现远程接口调用时，所需要执行的函数是存在于远程机器中，即函数是在另外一个进程中执行的。因此，就带来了几个新问题：</description>
    </item>
    
    <item>
      <title>Golang微服务开发-grpc</title>
      <link>http://myxy99.cn/posts/golang%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91-grpc/</link>
      <pubDate>Fri, 10 Jul 2020 08:12:21 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91-grpc/</guid>
      <description>什么是grpc grpc官网：https://www.grpc.io/
 A high-performance, open-source universal RPC framework
 这个是官方对他的解释。这里就出现了一个新的名称RPC。什么是RPC呢?</description>
    </item>
    
    <item>
      <title>Protoc-go修改生成的文件的结构体的tag</title>
      <link>http://myxy99.cn/posts/protoc-go%E4%BF%AE%E6%94%B9%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84tag/</link>
      <pubDate>Tue, 07 Jul 2020 09:22:38 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/protoc-go%E4%BF%AE%E6%94%B9%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84tag/</guid>
      <description>使用场景 在使用protoc生成的文件中生成的结构体的json没有小写，有时候我们就需要使用小写，最主要的就是在使用gin的时候还需要使用bind来绑定上传的东西。但是生成的*.pd.go又不建议我们去改。这时候就需要使用protoc-go-inject-tag，这里还有个更重要的地方，这里简单描述下：生成的结构体中的tag里面有个omitempty，这个的作用呢，就是在数据传输过程中，自动去掉false 0 &amp;quot;&amp;quot;这些数据。这里简单的举个例子，比如你的grpc服务端返回给客户端一个值为false的bool类型数据。但是在客户端接受的时候，这个字段就直接没有了。所以这样肯定是不行的。所以这里需要集体的去掉tag中的omitempty。这个时候protoc-go-inject-tag就可以满足这个需求。在之后的微服务（go-micro）开发中，这个也是很重要的地方！
git地址：https://github.com/favadi/protoc-go-inject-tag
安装 go get github.com/favadi/protoc-go-inject-tag 使用 只需要在.</description>
    </item>
    
  </channel>
</rss>
