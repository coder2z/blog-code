<!DOCTYPE html>
<html lang="en" data-theme="dark"><head>
    <title> Coder2z | Golang实现一致性Hash算法 </title>

    
    <meta charset="utf-8"><meta name="generator" content="Hugo 0.81.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="description" content="Hi I&#39;m Coder2z, nice to meet you">
    
    <link rel="stylesheet"
          href="http://myxy99.cn/css/style.min.d98386e9809c4644e290afb256e8aad6d2ae6b1aefe82c504efd652e6642708d.css"
          integrity="sha256-2YOG6YCcRkTikK&#43;yVuiq1tKuaxrv6CxQTv1lLmZCcI0="
          crossorigin="anonymous"
          type="text/css">
    
    <link rel="stylesheet"
        href="http://myxy99.cn/css/markupHighlight.min.f798cbda9aaa38f89eb38be6414bd082cfd71a6780375cbf67b6d2fb2b96491e.css"
        integrity="sha256-95jL2pqqOPies4vmQUvQgs/XGmeAN1y/Z7bS&#43;yuWSR4="
        crossorigin="anonymous"
        type="text/css">
    
    <link rel="stylesheet" 
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" 
    integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" 
    crossorigin="anonymous" />

    
    <link rel="shortcut icon" href="http://myxy99.cn/favicons/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="http://myxy99.cn/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="http://myxy99.cn/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="http://myxy99.cn/favicons/favicon-16x16.png">

    <link rel="canonical" href="http://myxy99.cn/posts/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/">

    
    
    
    
    <script type="text/javascript"
            src="http://myxy99.cn/js/anatole-header.min.0c05c0a90d28c968a1cad4fb31abd0b8e1264e788ccefed022ae1d3b6f627514.js"
            integrity="sha256-DAXAqQ0oyWihytT7MavQuOEmTniMzv7QIq4dO29idRQ="
            crossorigin="anonymous"></script>


    
        
        
        <script type="text/javascript"
                src="http://myxy99.cn/js/anatole-theme-switcher.min.8ef71e0fd43f21a303733dbbecae5438b791d2b826c68a9883bd7aa459a076d2.js"
                integrity="sha256-jvceD9Q/IaMDcz277K5UOLeR0rgmxoqYg716pFmgdtI="
                crossorigin="anonymous"></script>
    
    <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://myxy99.cn/images/site-feature-image.png"/>

<meta name="twitter:title" content="Golang实现一致性Hash算法"/>
<meta name="twitter:description" content="什么是一致性Hash算法 一致性Hash算法是使用取模的方法，一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：
圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1
我们把这个由2的32次方个点组成的圆环称为hash环。
假设我们有3台缓存服务器，服务器A、服务器B、服务器C，那么，在生产环境中，这三台服务器肯定有自己的IP地址，我们使用它们各自的IP地址进行哈希计算，使用哈希后的结果对2^32取模，可以使用如下公式示意
 hash(服务器A的IP地址) % 2^32
 通过上述公式算出的结果一定是一个0到2^32-1之间的一个整数，我们就用算出的这个整数，代表服务器A，既然这个整数肯定处于0到2^32-1之间，那么，上图中的hash环上必定有一个点与这个整数对应，而我们刚才已经说明，使用这个整数代表服务器A，那么，服务器A就可以映射到这个环上，用下图示意"/>


    

</head>
<body><div class="sidebar animated fadeInDown ">
    <div class="logo-title">
        <div class="title">
            <img src="http://myxy99.cn/images/profile.png" alt="profile picture">
            <h3 title=""><a href="/">I&#39;m Coder2z</a></h3>
            <div class="description">
                <p>Hi I&#39;m Coder2z, nice to meet you</p>
            </div>
        </div>
    </div>
    <ul class="social-links">
        
            <li>
                <a href="https://de.linkedin.com/" rel="me" aria-label="Linkedin">
                    <i class="fab fa-linkedin fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="https://github.com/lxndrblz/anatole/" rel="me" aria-label="GitHub">
                    <i class="fab fa-github fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="https://www.instagram.com/" rel="me" aria-label="instagram">
                    <i class="fab fa-instagram fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="mailto:mail@example.com" rel="me" aria-label="e-mail">
                    <i class="fas fa-envelope fa-2x" aria-hidden="true"></i>
                </a>
            </li>
        
    </ul>
    <div class="footer">
        <div class="by_farbox">&copy; Coder2z  2019-2021 </div>
    </div>
</div>
<div class="main">
    <div class="page-top  animated fadeInDown ">
    <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
    </a>
    <ul class="nav" id="navMenu">
        
        
            
            <li><a 
                   href="/"
                        
                   title="">Home</a></li>
        
            
            <li><a 
                   href="/posts/"
                        
                   title="">Posts</a></li>
        
            
            <li><a 
                   href="/about/"
                        
                   title="">About</a></li>
        
            
            <li><a 
                   href="/categories/"
                        
                   title="">categories</a></li>
        
        
        
            <li class="theme-switch-item">
                <a class="theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </li>
        
    </ul>
</div>

    <div class="autopagerize_page_element">
        <div class="content">
    <div class="post  animated fadeInDown ">
        <div class="post-content">
            
            <div class="post-title">
                <h3>Golang实现一致性Hash算法</h3>
                
            </div>

            <h1 id="什么是一致性hash算法">什么是一致性Hash算法</h1>
<p>一致性Hash算法是使用取模的方法，一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：</p>
<p><img src="https://gitee.com/coder2m/pic/raw/master/img/20200709195951.png" alt=""></p>
<p>圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1</p>
<p>我们把这个由2的32次方个点组成的圆环称为hash环。</p>
<p>假设我们有3台缓存服务器，服务器A、服务器B、服务器C，那么，在生产环境中，这三台服务器肯定有自己的IP地址，我们使用它们各自的IP地址进行哈希计算，使用哈希后的结果对2^32取模，可以使用如下公式示意</p>
<blockquote>
<p>hash(服务器A的IP地址) %  2^32</p>
</blockquote>
<p>通过上述公式算出的结果一定是一个0到2^32-1之间的一个整数，我们就用算出的这个整数，代表服务器A，既然这个整数肯定处于0到2^32-1之间，那么，上图中的hash环上必定有一个点与这个整数对应，而我们刚才已经说明，使用这个整数代表服务器A，那么，服务器A就可以映射到这个环上，用下图示意</p>
<p><img src="https://gitee.com/coder2m/pic/raw/master/img/20200709201526.png" alt=""></p>
<p>同理，服务器B与服务器C也可以通过相同的方法映射到上图中的hash环中。所以现在的hash环：</p>
<p><img src="https://gitee.com/coder2m/pic/raw/master/img/20200709201713.png" alt=""></p>
<p>这样我们的服务器就映射到了hash环上，现在我们同理也就可以把我们需要访问的对象也放在hash环上。</p>
<p>假设我们现在需要分别在三个服务器上放缓存的文件，我们就使用文件的名字作为计算hash的key：</p>
<blockquote>
<p>hash(文件名) %  2^32</p>
</blockquote>
<p>这样也能计算一个值，也就能映射到对应的hash环上。现在我们的hash环就变成了这个样子：</p>
<p><img src="https://gitee.com/coder2m/pic/raw/master/img/20200709202336.png" alt=""></p>
<p>计算出来了文件的hash值，下一步就是觉得那个服务器存储这个对象了。这里规定是：从计算出来的位置开始向顺时针方向遇到的第一个服务器，进行存储。所以这里文件就会存储在服务器B上。</p>
<p>这就是一致性hash算法。</p>
<h1 id="优点">优点</h1>
<p>这里我们假设，我们的服务器B突然失效了,我们上面例子中的文件就会存储到服务器c中，这样就算是缓存失效。但是这里服务器失效的是A,就对上面例子中的文件不会有任何的影响。使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有缓存都会失效，而是只有部分缓存会失效，前端的缓存仍然能分担整个系统的压力，而不至于所有压力都在同一时间集中到后端服务器上。这就是一致性哈希算法所体现出的优点。</p>
<h1 id="hash环的偏斜">hash环的偏斜</h1>
<p>理想情况下我们的3个服务器是如上图所示，均匀的分布在hash环上，但是理想往往和现实差距很大：</p>
<p><img src="https://gitee.com/coder2m/pic/raw/master/img/20200709203438.png" alt=""></p>
<p>实际上映射中，服务器可能会被映射成这样：</p>
<p><img src="https://gitee.com/coder2m/pic/raw/master/img/20200709203659.png" alt=""></p>
<p>这种情况下缓存的对象很有可能大部分集中缓存在某一台服务器。这就很难受了。这就是hash环的偏斜。那么，我们应该怎样防止hash环的偏斜呢？</p>
<h1 id="虚拟节点">虚拟节点</h1>
<p>虚拟节点就是来解决hash环偏斜的问题的。顾名思义就是在hash环上创建每个服务器的副本，是&quot;实际节点&quot;（实际的物理服务器）在hash环上的复制品,一个实际节点可以对应多个虚拟节点，创建副本后的hash环就变成了这样：</p>
<p><img src="https://gitee.com/coder2m/pic/raw/master/img/20200709204300.png" alt=""></p>
<p>这样就解决了偏移问题。虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大。</p>
<h1 id="golang中实现hash环">Golang中实现hash环</h1>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kn">package</span> <span class="nx">hash</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;errors&#34;</span>
	<span class="s">&#34;hash/crc32&#34;</span>
	<span class="s">&#34;sort&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="c1">//声明新切片类型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">units</span> <span class="p">[]</span><span class="kt">uint32</span>

<span class="c1">//返回切片长度
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">units</span><span class="p">)</span> <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//比对两个数大小
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">units</span><span class="p">)</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">//切片中两个值的交换
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">units</span><span class="p">)</span> <span class="nf">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">//创建结构体保存一致性hash信息
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ConsistentHash</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">//hash环，key为哈希值，值存放节点的信息
</span><span class="c1"></span>	<span class="nx">circle</span> <span class="kd">map</span><span class="p">[</span><span class="kt">uint32</span><span class="p">]</span><span class="kt">string</span>
	<span class="c1">//已经排序的节点hash切片
</span><span class="c1"></span>	<span class="nx">sortedHashes</span> <span class="nx">units</span>
	<span class="c1">//虚拟节点个数，用来增加hash的平衡性
</span><span class="c1"></span>	<span class="nx">VirtualNode</span> <span class="kt">int</span>
	<span class="c1">//map 读写锁
</span><span class="c1"></span>	<span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
<span class="p">}</span>

<span class="c1">//创建一致性hash算法结构体，设置默认节点数量
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewConsistent</span><span class="p">(</span><span class="nx">nodeNum</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">ConsistentHash</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">ConsistentHash</span><span class="p">{</span>
		<span class="c1">//初始化变量
</span><span class="c1"></span>		<span class="nx">circle</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">uint32</span><span class="p">]</span><span class="kt">string</span><span class="p">),</span>
		<span class="c1">//设置虚拟节点个数
</span><span class="c1"></span>		<span class="nx">VirtualNode</span><span class="p">:</span> <span class="nx">nodeNum</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//自动生成key值
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ConsistentHash</span><span class="p">)</span> <span class="nf">generateKey</span><span class="p">(</span><span class="nx">element</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="c1">//副本key生成逻辑
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">element</span> <span class="o">+</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//获取hash位置 计算key 在hash环中对应的位置
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ConsistentHash</span><span class="p">)</span> <span class="nf">hashKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
	<span class="c1">//当长度不够填充
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">64</span> <span class="p">{</span>
		<span class="c1">//声明一个数组长度为64
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">tmpList</span> <span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="kt">byte</span>
		<span class="c1">//拷贝数据到数组中
</span><span class="c1"></span>		<span class="nb">copy</span><span class="p">(</span><span class="nx">tmpList</span><span class="p">[:],</span> <span class="nx">key</span><span class="p">)</span>
		<span class="c1">//使用IEEE 多项式返回数据的CRC-32校验和
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">crc32</span><span class="p">.</span><span class="nf">ChecksumIEEE</span><span class="p">(</span><span class="nx">tmpList</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">key</span><span class="p">)])</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">crc32</span><span class="p">.</span><span class="nf">ChecksumIEEE</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">//更新排序，方便查找 因为后面我们使用的是sort.Search进行查找 sort.Search使用的是二分法进行查找，所以这里需要排序
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ConsistentHash</span><span class="p">)</span> <span class="nf">updateSortedHashes</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">hashes</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sortedHashes</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
	<span class="c1">//判断切片容量，是否过大，如果过大则重置
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">sortedHashes</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">VirtualNode</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">circle</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">hashes</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">//添加hashes
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">circle</span> <span class="p">{</span>
		<span class="nx">hashes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">hashes</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">//对所有节点hash值进行排序，
</span><span class="c1"></span>	<span class="c1">//方便之后进行二分查找
</span><span class="c1"></span>	<span class="nx">sort</span><span class="p">.</span><span class="nf">Sort</span><span class="p">(</span><span class="nx">hashes</span><span class="p">)</span>
	<span class="c1">//重新赋值
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">sortedHashes</span> <span class="p">=</span> <span class="nx">hashes</span>
<span class="p">}</span>

<span class="c1">//向hash环中添加节点
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ConsistentHash</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">element</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//加锁
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="c1">//解锁
</span><span class="c1"></span>	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//添加节点
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ConsistentHash</span><span class="p">)</span> <span class="nf">add</span><span class="p">(</span><span class="nx">element</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//循环虚拟节点，设置副本
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">VirtualNode</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">//根据生成的节点添加到hash环中
</span><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">circle</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nf">hashKey</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">generateKey</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">i</span><span class="p">))]</span> <span class="p">=</span> <span class="nx">element</span>
	<span class="p">}</span>
	<span class="c1">//更新排序
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nf">updateSortedHashes</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">//删除节点
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ConsistentHash</span><span class="p">)</span> <span class="nf">remove</span><span class="p">(</span><span class="nx">element</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">VirtualNode</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nb">delete</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">circle</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">hashKey</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">generateKey</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">i</span><span class="p">)))</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">updateSortedHashes</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">//删除一个节点
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ConsistentHash</span><span class="p">)</span> <span class="nf">Remove</span><span class="p">(</span><span class="nx">element</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//顺时针查找最近的节点
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ConsistentHash</span><span class="p">)</span> <span class="nf">search</span><span class="p">(</span><span class="nx">key</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">//查找算法
</span><span class="c1"></span>	<span class="nx">f</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sortedHashes</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">key</span>
	<span class="p">}</span>
	<span class="c1">//使用&#34;二分查找&#34;算法来搜索指定切片满足条件的最小值
</span><span class="c1"></span>	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">sort</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">sortedHashes</span><span class="p">),</span> <span class="nx">f</span><span class="p">)</span>
	<span class="c1">//如果超出范围则设置i=0
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">sortedHashes</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>

<span class="c1">//根据数据标示获取最近的服务器节点信息
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ConsistentHash</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//添加锁
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="c1">//解锁
</span><span class="c1"></span>	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
	<span class="c1">//如果为零则返回错误
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">circle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;hash环没有数据&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">//计算hash值
</span><span class="c1"></span>	<span class="nx">key</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">hashKey</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
	<span class="nx">i</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">circle</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">sortedHashes</span><span class="p">[</span><span class="nx">i</span><span class="p">]],</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><p>这样就很简单的实现了golong的一致性hash。</p>
<blockquote>
<p>这里提一下，为什么是2^32呢?因为这个算法的出现就算为了解决分布式问题，所以在分布式中基本上存储的就算服务器的ip，IPv4的地址是4组8位2进制数组成，所以用2^32可以保证每个IP地址会有唯一的映射。</p>
</blockquote>
<p>参考连接：<a href="https://www.cnblogs.com/williamjie/p/9477852.html">https://www.cnblogs.com/williamjie/p/9477852.html</a></p>
</div>
        <div class="post-footer">
            <div class="info">
                <span class="separator"><a class="category" href="/categories/golang/">golang</a></span>

                <span class="separator"><a class="tag" href="/tags/golang/">golang</a><a class="tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="tag" href="/tags/%E4%B8%80%E8%87%B4%E6%80%A7hash/">一致性Hash</a><a class="tag" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span>

            </div>
        </div>

        
    </div>


        </div>
    </div>
</div>

<script type="text/javascript"
        src="http://myxy99.cn/js/medium-zoom.min.2d6fd0be87fa98f0c9b4dc2536b312bbca48757f584f6ea1f394abc9bcc38fbc.js"
        integrity="sha256-LW/Qvof6mPDJtNwlNrMSu8pIdX9YT26h85SrybzDj7w="
        crossorigin="anonymous"></script></body>

</html>
