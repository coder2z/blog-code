<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coder2z Blog</title>
    <link>http://myxy99.cn/</link>
    <description>Recent content on Coder2z Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 15 Sep 2020 09:35:21 +0800</lastBuildDate><atom:link href="http://myxy99.cn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>About</title>
      <link>http://myxy99.cn/about/</link>
      <pubDate>Thu, 18 Mar 2021 22:40:02 +0800</pubDate>
      
      <guid>http://myxy99.cn/about/</guid>
      <description>关于我 成都东软学院信息与软件工程系的本科在读学生，喜欢coding，生活，音乐，电影，爱捣鼓网站上的一些奇怪的东西，拥有轻度选择恐惧症。
主攻方向：Go后端开发
type PersonalInformation struct { Name string Age int64 Address string Email string Description string } type Skills struct { Skill []string } func Me() (PersonalInformation, Skills) { information := PersonalInformation{ Name: &amp;#34;YangZemiao&amp;#34;, Age: 21, Address: &amp;#34;SiChuan&amp;#34;, Email: &amp;#34;myxy99@foxmail.</description>
    </item>
    
    <item>
      <title>Golang踩坑笔记</title>
      <link>http://myxy99.cn/posts/golang%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 15 Sep 2020 09:35:21 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</guid>
      <description>golang中的一些陷阱 int和float64类型不匹配 Go类型系统不允许在整数和浮点变量之间进行任何数学运算。
比如
package main import &amp;#34;fmt&amp;#34; func main() { var x, y = 13, 3.</description>
    </item>
    
    <item>
      <title>Golang实现Google-Authenticator</title>
      <link>http://myxy99.cn/posts/golang%E5%AE%9E%E7%8E%B0google-authenticator/</link>
      <pubDate>Wed, 05 Aug 2020 20:43:46 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang%E5%AE%9E%E7%8E%B0google-authenticator/</guid>
      <description>什么是Google-Authenticator Google身份验证器是一款基于时间与哈希的一次性密码算法的两步验证软件令牌。也就是我们署成的TOTP（Time-based One-time Password）
通俗的说就是：密钥+算法=code
通过控制变量法，这里我们只需要手机上也设置一样的密钥使用一样的算法，就可以生成一样的code，从而达到二次验证。
使用Go实现生成密码算法 /** * @Author: myxy99 &amp;lt;myxy99@foxmail.</description>
    </item>
    
    <item>
      <title>Golang-MongoDb方法封装</title>
      <link>http://myxy99.cn/posts/golang-mongodb%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85/</link>
      <pubDate>Thu, 30 Jul 2020 14:09:50 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang-mongodb%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85/</guid>
      <description>Golang操作MongoDb 安装依赖 go get -u github.com/globalsign/mgo MongoDb的方法封装 /** * @Author: myxy99 &amp;lt;myxy99@foxmail.</description>
    </item>
    
    <item>
      <title>单链表中间节点</title>
      <link>http://myxy99.cn/posts/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</link>
      <pubDate>Mon, 27 Jul 2020 13:23:46 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</guid>
      <description>单链表中间节点 方法一 首先先遍历一遍获得节点个数，然后取一半作计数器再次遍历。这个方法遍历了两次，是最慢的方法
class Node: def __init__(self, data, next): self.data = data self.</description>
    </item>
    
    <item>
      <title>go-micro开发微服务聊天室</title>
      <link>http://myxy99.cn/posts/go-micro%E5%BC%80%E5%8F%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%81%8A%E5%A4%A9%E5%AE%A4/</link>
      <pubDate>Fri, 24 Jul 2020 14:06:27 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/go-micro%E5%BC%80%E5%8F%91%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%81%8A%E5%A4%A9%E5%AE%A4/</guid>
      <description>基于go-micro开发的微服务聊天室 技术栈  微服务框架：go-micro
  web框架：gin
  orm:gorm</description>
    </item>
    
    <item>
      <title>Golang-mod</title>
      <link>http://myxy99.cn/posts/golang-mod/</link>
      <pubDate>Tue, 21 Jul 2020 11:13:36 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang-mod/</guid>
      <description>Golang-mod go modules 是相关Go包的集合。modules是源代码交换和版本控制的单元。 go命令直接支持使用modules，包括记录和解析对其他模块的依赖性。modules替换旧的基于GOPATH的方法来指定在给定构建中使用哪些源文件。(go官方的解释)
使用Mod 开启go mod go env -w GO111MODULE=on // 开启go mod  go mod有以下命令：    命令 说明     download download modules to local cache(下载依赖包)   edit edit go.</description>
    </item>
    
    <item>
      <title>Golang与Apollo配置中心</title>
      <link>http://myxy99.cn/posts/golang%E4%B8%8Eapollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</link>
      <pubDate>Sat, 18 Jul 2020 07:53:14 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang%E4%B8%8Eapollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</guid>
      <description>Apollo - A reliable configuration management system Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。
服务端基于Spring Boot和Spring Cloud开发，打包后可以直接运行，不需要额外安装Tomcat等应用容器。</description>
    </item>
    
    <item>
      <title>Golang使用WebSocket</title>
      <link>http://myxy99.cn/posts/golang%E4%BD%BF%E7%94%A8websocket/</link>
      <pubDate>Fri, 17 Jul 2020 11:19:32 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang%E4%BD%BF%E7%94%A8websocket/</guid>
      <description>Golang使用WebSocket WebSocket是一种通信协议，旨在改善HTTP作为无状态协议通信的效率问题，WebSocket是客户端与服务器之间的全双工连接，客户端和服务器只需要建立一次连接就可以使用该连接进行通信。在我们的项目中，一般客户端是前端页面，使用JavaScript创建WebSocket与后端的WebSocket服务端进行通信。
安装依赖 go get -u github.com/gorilla/websocket
封装方法 package websocketConn import ( &amp;#34;errors&amp;#34; &amp;#34;github.</description>
    </item>
    
    <item>
      <title>Golang实现将Hexo博客文章推送到微信公众号</title>
      <link>http://myxy99.cn/posts/golang%E5%AE%9E%E7%8E%B0%E5%B0%86hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8E%A8%E9%80%81%E5%88%B0%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/</link>
      <pubDate>Wed, 15 Jul 2020 10:53:59 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang%E5%AE%9E%E7%8E%B0%E5%B0%86hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%8E%A8%E9%80%81%E5%88%B0%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/</guid>
      <description>Golang实现将Hexo博客文章推送到微信公众号 最近在写博客的时候，就在想，能不能实现博客更新了然后就自动给别人提醒呢？比如每天提醒更新了什么博客。然后就有了这个项目，我的想法就是通过golang进行爬虫，把所有的文章都存储起来，获取到新的文章，然后把新的文章连接进行整合，发送到微信公众号，这样所有的关注了微信公众号的，就能收到，每天更新的新的博客。
实现爬虫 这里我选择的是colly爬虫框架。然后把爬取的数据进行数据库存储。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/gocolly/colly&amp;#34; &amp;#34;regexp&amp;#34; &amp;#34;strings&amp;#34; &amp;#34;wx-blog/config&amp;#34; Redis &amp;#34;wx-blog/redis&amp;#34; &amp;#34;wx-blog/utils&amp;#34; ) func main() { i := config.</description>
    </item>
    
    <item>
      <title>Golang遇上NSQ消息队列</title>
      <link>http://myxy99.cn/posts/golang%E9%81%87%E4%B8%8Ansq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link>
      <pubDate>Tue, 14 Jul 2020 22:00:38 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang%E9%81%87%E4%B8%8Ansq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid>
      <description>简介 NSQ是一个基于Go语言的分布式实时消息平台, 它具有分布式、去中心化的拓扑结构，支持无限水平扩展。无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征。另外，NSQ非常容易配置和部署, 且支持众多的消息协议。支持多种客户端，协议简单。
NSQ的几个组件  nsqd：一个负责接收、排队、转发消息到客户端的守护进程 nsqlookupd：管理拓扑信息, 用于收集nsqd上报的topic和channel,并提供最终一致性的发现服务的守护进程 nsqadmin：一套Web用户界面，可实时查看集群的统计数据和执行相应的管理任务  Docker安装 搭建主NSQ服务 获取到自己的服务器ip 我这里就是我服务器的外网ip 39.</description>
    </item>
    
    <item>
      <title>Gin表单绑定验证器</title>
      <link>http://myxy99.cn/posts/gin%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A%E9%AA%8C%E8%AF%81%E5%99%A8/</link>
      <pubDate>Mon, 13 Jul 2020 08:34:28 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/gin%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A%E9%AA%8C%E8%AF%81%E5%99%A8/</guid>
      <description>gin中内置validator的基础使用 type UserLoginParam struct { Name string `form:&amp;#34;name&amp;#34; json:&amp;#34;name&amp;#34; binding:&amp;#34;required,min=2,max=30&amp;#34;` Password string `form:&amp;#34;password&amp;#34; json:&amp;#34;password&amp;#34; binding:&amp;#34;required,min=8,max=40&amp;#34;` } func TestValidator(t *testing.</description>
    </item>
    
    <item>
      <title>Protobuf通信协议</title>
      <link>http://myxy99.cn/posts/protobuf%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Sun, 12 Jul 2020 15:52:44 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/protobuf%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</guid>
      <description>RPC的调用过程 一个正常的RPC过程可以分为一下几个步骤：
 client调用client stub，这是一次本地过程调用。 client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做marshalling。 client所在的系统将消息发送给server。 server的的系统将收到的包传给server stub。 server stub解包得到参数。 解包也被称作 unmarshalling。 server stub调用服务过程。返回结果按照相反的步骤传给client。  在上述的步骤实现远程接口调用时，所需要执行的函数是存在于远程机器中，即函数是在另外一个进程中执行的。因此，就带来了几个新问题：</description>
    </item>
    
    <item>
      <title>Golang开发分布式电商网站高并发秒杀系统</title>
      <link>http://myxy99.cn/posts/golang%E5%BC%80%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sat, 11 Jul 2020 10:21:53 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang%E5%BC%80%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</guid>
      <description>这个系统的主要目的在于秒杀，所有其他地方都做的很简单。基础功能不多！
 技术栈：  web框架：gin
  消息队列：RabbitMQ
  分布式方案：hash环</description>
    </item>
    
    <item>
      <title>Golang中的ORM-Gorm的关联模型</title>
      <link>http://myxy99.cn/posts/golang%E4%B8%AD%E7%9A%84orm-gorm%E7%9A%84%E5%85%B3%E8%81%94%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 10 Jul 2020 09:09:28 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang%E4%B8%AD%E7%9A%84orm-gorm%E7%9A%84%E5%85%B3%E8%81%94%E6%A8%A1%E5%9E%8B/</guid>
      <description>Golang中的ORM-Gorm的关联模型 对于gorm的基础CRUD用法，这里就不论述了，这里主要说下关联模型的问题，因为我自己在查看官方文档进行关联模型操作的时候，总是感觉官方的例子很奇怪，用着很不明白。对于gorm的基础CRUD用法，不明白的可以看看官方文档：https://gorm.io/zh_CN/docs/models.html
创建数据库层面的外键： models.MysqlHandler.Model(&amp;amp;models.Order{}).AddForeignKey(&amp;#34;user_id&amp;#34;, &amp;#34;user(id)&amp;#34;, &amp;#34;RESTRICT&amp;#34;, &amp;#34;RESTRICT&amp;#34;) 说说这里的RESTRICT，这里还可以填CASCADE、NO ACTION、RESTRICT、SET NULL。分别的意思是：</description>
    </item>
    
    <item>
      <title>Golang微服务开发-grpc</title>
      <link>http://myxy99.cn/posts/golang%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91-grpc/</link>
      <pubDate>Fri, 10 Jul 2020 08:12:21 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91-grpc/</guid>
      <description>什么是grpc grpc官网：https://www.grpc.io/
 A high-performance, open-source universal RPC framework
 这个是官方对他的解释。这里就出现了一个新的名称RPC。什么是RPC呢?</description>
    </item>
    
    <item>
      <title>Golang实现一致性Hash算法</title>
      <link>http://myxy99.cn/posts/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 09 Jul 2020 19:49:48 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</guid>
      <description>什么是一致性Hash算法 一致性Hash算法是使用取模的方法，一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：
圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1
我们把这个由2的32次方个点组成的圆环称为hash环。
假设我们有3台缓存服务器，服务器A、服务器B、服务器C，那么，在生产环境中，这三台服务器肯定有自己的IP地址，我们使用它们各自的IP地址进行哈希计算，使用哈希后的结果对2^32取模，可以使用如下公式示意
 hash(服务器A的IP地址) % 2^32
 通过上述公式算出的结果一定是一个0到2^32-1之间的一个整数，我们就用算出的这个整数，代表服务器A，既然这个整数肯定处于0到2^32-1之间，那么，上图中的hash环上必定有一个点与这个整数对应，而我们刚才已经说明，使用这个整数代表服务器A，那么，服务器A就可以映射到这个环上，用下图示意</description>
    </item>
    
    <item>
      <title>Golang使用jwt</title>
      <link>http://myxy99.cn/posts/golang%E4%BD%BF%E7%94%A8jwt/</link>
      <pubDate>Tue, 07 Jul 2020 20:35:19 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang%E4%BD%BF%E7%94%A8jwt/</guid>
      <description>Golang中使用JWT(json web token) 什么是jwt 什么是jwt这里就不多说了，官网有介绍。官网介绍：https://jwt.io/introduction/
使用步骤 下载依赖包 go get -u github.</description>
    </item>
    
    <item>
      <title>Protoc-go修改生成的文件的结构体的tag</title>
      <link>http://myxy99.cn/posts/protoc-go%E4%BF%AE%E6%94%B9%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84tag/</link>
      <pubDate>Tue, 07 Jul 2020 09:22:38 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/protoc-go%E4%BF%AE%E6%94%B9%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84tag/</guid>
      <description>使用场景 在使用protoc生成的文件中生成的结构体的json没有小写，有时候我们就需要使用小写，最主要的就是在使用gin的时候还需要使用bind来绑定上传的东西。但是生成的*.pd.go又不建议我们去改。这时候就需要使用protoc-go-inject-tag，这里还有个更重要的地方，这里简单描述下：生成的结构体中的tag里面有个omitempty，这个的作用呢，就是在数据传输过程中，自动去掉false 0 &amp;quot;&amp;quot;这些数据。这里简单的举个例子，比如你的grpc服务端返回给客户端一个值为false的bool类型数据。但是在客户端接受的时候，这个字段就直接没有了。所以这样肯定是不行的。所以这里需要集体的去掉tag中的omitempty。这个时候protoc-go-inject-tag就可以满足这个需求。在之后的微服务（go-micro）开发中，这个也是很重要的地方！
git地址：https://github.com/favadi/protoc-go-inject-tag
安装 go get github.com/favadi/protoc-go-inject-tag 使用 只需要在.</description>
    </item>
    
    <item>
      <title>Golang实现依赖注入&#43;gin</title>
      <link>http://myxy99.cn/posts/golang%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5&#43;gin/</link>
      <pubDate>Sun, 05 Jul 2020 10:06:47 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5&#43;gin/</guid>
      <description>Go实现依赖注入 最近在使用go开发的时候，发现构建系统依赖树非常繁琐，需要手动去new很多对象，又手工代码将它们拼接起来，写了一堆非常冗繁的代码。之前在laravel的使用中有其强大的ioc，都没有这方面的困扰。就在想golang中有没有好用的依赖注入方案，查询资料，发现了facebook团队开源的inject。GitHub地址：http://github.com/facebookgo/inject
没有依赖注入的系统： 在代码上的表现：
func NewUserRepository() UserRepositoryImp { return &amp;amp;UserManagerRepository{ Db: models.</description>
    </item>
    
    <item>
      <title>Golang实现RabbitMQ五种模式</title>
      <link>http://myxy99.cn/posts/golang%E5%AE%9E%E7%8E%B0rabbitmq%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 03 Jul 2020 09:16:26 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang%E5%AE%9E%E7%8E%B0rabbitmq%E4%BA%94%E7%A7%8D%E6%A8%A1%E5%BC%8F/</guid>
      <description>使用的依赖包 github.com/streadway/amqp 创建RabbitMQ实例 package RabbitMQ import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/streadway/amqp&amp;#34; &amp;#34;log&amp;#34; ) // 用户名 密码 ip:端口/虚拟机 const MQURL = &amp;#34;amqp://admin:123456@127.</description>
    </item>
    
    <item>
      <title>Golang-Redis简易封装</title>
      <link>http://myxy99.cn/posts/golang-redis%E7%AE%80%E6%98%93%E5%B0%81%E8%A3%85/</link>
      <pubDate>Wed, 01 Jul 2020 21:12:47 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang-redis%E7%AE%80%E6%98%93%E5%B0%81%E8%A3%85/</guid>
      <description>Golang Redis 下载依赖包 go get github.com/gomodule/redigo Redis 操作封装 配置文件 [redis] Host = 127.</description>
    </item>
    
    <item>
      <title>Golang邮件发送</title>
      <link>http://myxy99.cn/posts/golang%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/</link>
      <pubDate>Sat, 27 Jun 2020 19:27:48 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/</guid>
      <description>golang发送邮件 安装库 go get github.com/jordan-wright/email 简单代码实现 package main import ( &amp;#34;log&amp;#34; &amp;#34;net/smtp&amp;#34; &amp;#34;github.</description>
    </item>
    
    <item>
      <title>Jenkins插件安装提速</title>
      <link>http://myxy99.cn/posts/jenkins%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E6%8F%90%E9%80%9F/</link>
      <pubDate>Tue, 23 Jun 2020 14:46:27 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/jenkins%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E6%8F%90%E9%80%9F/</guid>
      <description>操作步骤 配置Json其实在Jenkins的工作目录中
cd {你的Jenkins工作目录}/updates #进入更新配置位置 第一种方式：使用vim vim default.json 使用vim的命令，如下，替换所有插件下载的url
:1,$s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g 替换连接测试url</description>
    </item>
    
    <item>
      <title>Golang实现雪花算法</title>
      <link>http://myxy99.cn/posts/golang%E5%AE%9E%E7%8E%B0%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 16 Jun 2020 13:09:56 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang%E5%AE%9E%E7%8E%B0%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</guid>
      <description>雪花算法 雪花算法 雪花算法的原始版本是scala版，用于生成分布式ID（纯数字，时间顺序）,订单编号等 自增ID：对于数据敏感场景不宜使用，且不适合于分布式场景。 GUID：采用无意义字符串，数据量增大时造成访问过慢，且不宜排序。
算法描述  最高位是符号位，始终为0，不可用。 41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。 10位的机器标识，10位的长度最多支持部署1024个节点。 12位的计数序列号，序列号即一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。  Golang 实现 package main import ( &amp;#34;errors&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) const ( workerBits uint8 = 10 numberBits uint8 = 12 workerMax int64 = -1 ^ (-1 &amp;lt;&amp;lt; workerBits) numberMax int64 = -1 ^ (-1 &amp;lt;&amp;lt; numberBits) timeShift uint8 = workerBits + numberBits workerShift uint8 = numberBits startTime int64 = 1525705533000 // 如果在程序跑了一段时间修改了epoch这个值 可能会导致生成相同的ID ) type Worker struct { mu sync.</description>
    </item>
    
    <item>
      <title>Golang-HTTP-Server</title>
      <link>http://myxy99.cn/posts/golang-http-server/</link>
      <pubDate>Mon, 01 Jun 2020 16:49:56 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/golang-http-server/</guid>
      <description>GO HTTP Server 使用标准库构建 HTTP 服务 Go 语言标准库自带一个完善的 net/http 包，可以很方便编写一个可以直接运行的 Web 服务。</description>
    </item>
    
    <item>
      <title>laravel实现定时任务</title>
      <link>http://myxy99.cn/posts/laravel%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Mon, 25 May 2020 10:11:13 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/laravel%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid>
      <description>laravel实现定时任务 原理是通过Cron
Cron简介 Cron 是 UNIX、SOLARIS、LINUX 下的一个十分有用的工具，通过 Cron 脚本能使计划任务定期地在系统后台自动运行。这种计划任务在 UNIX、SOLARIS、LINUX下术语为 Cron Jobs。Crontab 则是用来记录在特定时间运行的 Cron 的一个脚本文件，Crontab 文件的每一行均遵守特定的格式：</description>
    </item>
    
    <item>
      <title>laravel-admin修改form默认的js引用</title>
      <link>http://myxy99.cn/posts/laravel-admin%E4%BF%AE%E6%94%B9form%E9%BB%98%E8%AE%A4%E7%9A%84js%E5%BC%95%E7%94%A8/</link>
      <pubDate>Fri, 22 May 2020 10:33:36 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/laravel-admin%E4%BF%AE%E6%94%B9form%E9%BB%98%E8%AE%A4%E7%9A%84js%E5%BC%95%E7%94%A8/</guid>
      <description>解决laravel-admin中form表单下拉框不是中文问题 最近在使用laravel-admin开发得时候。在做表单提交的时候发现默认的提醒为英文的这里我就想能不能设置为中文： 然后我就在线怎么操作能够改为中文，我这里通过了通过在开发工具中搜索，我发现这里的渲染为js进行的： 这里我发现在对应得文件夹中也有中文版本得js只是没有使用上： 所以这里我就在想怎么修改默认的js路径，于是我开始使用开发工具继续搜索这个js名 结果在这个文件中发现了js的设置，现在就要想怎么修改他了，直接修改他的源代码肯定是不行的，所以这里我想的就是继承这个类在进行重写变量赋值。 现在的问题就是怎么让我们的类生效了，查看了官方文档发现只需要在bootstrap中注册就行了 现在再查看下页面就变成中文了 这里其实就是一个小问题，但是主要是再发现问题得时候，怎么一步一步得找到问题，进行解决。记录一下这个思路 参考连接：https://laravel-admin.org/docs/zh</description>
    </item>
    
    <item>
      <title>laravel通过观察者监听模型事件</title>
      <link>http://myxy99.cn/posts/laravel%E9%80%9A%E8%BF%87%E8%A7%82%E5%AF%9F%E8%80%85%E7%9B%91%E5%90%AC%E6%A8%A1%E5%9E%8B%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Wed, 20 May 2020 10:08:28 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/laravel%E9%80%9A%E8%BF%87%E8%A7%82%E5%AF%9F%E8%80%85%E7%9B%91%E5%90%AC%E6%A8%A1%E5%9E%8B%E4%BA%8B%E4%BB%B6/</guid>
      <description>所有支持的模型事件 在 Eloquent 模型类上进行查询、插入、更新、删除操作时，会触发相应的模型事件（关于事件我们后面会单独讲），不管你有没有监听它们。这些事件包括：
   方法名 说明     retrieved 获取到模型实例后触发   creating 插入到数据库前触发   created 插入到数据库后触发   updating 更新到数据库前触发   updated 更新到数据库后触发   saving 保存到数据库前触发（插入/更新之前，无论插入还是更新都会触发）   saved 保存到数据库后触发（插入/更新之后，无论插入还是更新都会触发）   deleting 从数据库删除记录前触发   deleted 从数据库删除记录后触发   restoring 恢复软删除记录前触发   restored 恢复软删除记录后触发    通过观察者监听模型事件 针对模型事件这种特殊的事件类型，Laravel 还为我们提供了观察者类来处理模型事件的监听。观察者可以看作是上述订阅者处理模型事件的简化版本，我们不需要自定义事件类，不需要建立映射关系，只需要在观察者类中将需要监听的事件定义为同名方法，并在相应方法中编写业务处理代码即可。当某个模型事件触发时，Eloquent 底层会去该模型上注册的观察者类中通过反射查找是否定义了对应的方法，如果定义了则执行相应的逻辑，否则忽略。</description>
    </item>
    
    <item>
      <title>laravel的Requests验证表单优化</title>
      <link>http://myxy99.cn/posts/laravel%E7%9A%84requests%E9%AA%8C%E8%AF%81%E8%A1%A8%E5%8D%95%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sun, 10 May 2020 11:10:25 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/laravel%E7%9A%84requests%E9%AA%8C%E8%AF%81%E8%A1%A8%E5%8D%95%E4%BC%98%E5%8C%96/</guid>
      <description>laravel的Requests验证表单优化 首先使用 artisan 建立 request php artisan make:request 方法名 就会在app/requests下生成对应文件名</description>
    </item>
    
    <item>
      <title>php对后台返回数据进行加密</title>
      <link>http://myxy99.cn/posts/php%E5%AF%B9%E5%90%8E%E5%8F%B0%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86/</link>
      <pubDate>Wed, 29 Apr 2020 22:32:49 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/php%E5%AF%B9%E5%90%8E%E5%8F%B0%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86/</guid>
      <description>php对后台返回数据进行加密，前端进行解密 生成加密密钥 生成私钥：
openssl genrsa -out rsa_1024_priv.pem 1024 生成对应的公钥：
openssl rsa -pubout -in rsa_1024_priv.</description>
    </item>
    
    <item>
      <title>laravel中的路由模型绑定</title>
      <link>http://myxy99.cn/posts/laravel%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9E%8B%E7%BB%91%E5%AE%9A/</link>
      <pubDate>Sat, 25 Apr 2020 09:48:12 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/laravel%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9E%8B%E7%BB%91%E5%AE%9A/</guid>
      <description>laravel中的路由模型绑定 在使用laravel进行开发的时候，会发现我们的控制器中多次出现了 $article = Article::findOrFail($id); 这一段代码。如果我们的程序能够自动找到 ID 对应的记录，并让 Laravel 自动查询，这是不是非常的棒？这就是路由模型绑定会做到的事情。</description>
    </item>
    
    <item>
      <title>laravel规范API返回的JSON格式</title>
      <link>http://myxy99.cn/posts/laravel%E8%A7%84%E8%8C%83api%E8%BF%94%E5%9B%9E%E7%9A%84json%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Fri, 10 Apr 2020 22:01:59 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/laravel%E8%A7%84%E8%8C%83api%E8%BF%94%E5%9B%9E%E7%9A%84json%E6%A0%BC%E5%BC%8F/</guid>
      <description>laravel 规范API返回的JSON格式 在最近开发项目的时候使用Laravel框架，对api进行返回数据的时候，在团队开发的时候太随意了，缺少一个统一的结构来包装返回值，所以就需要进行返回格式的统一
这里我就介绍两个方法：
ServiceProvider方法 创建一个ServiceProvider 命令行输入：
php artisan make:provider ResponseServiceProvider 在boot绑定response响应宏 这一步主要就是给自带的response方法添加一些自己的方法：</description>
    </item>
    
    <item>
      <title>Python-matplotlib的使用</title>
      <link>http://myxy99.cn/posts/python-matplotlib%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 15 Mar 2020 20:01:49 +0800</pubDate>
      
      <guid>http://myxy99.cn/posts/python-matplotlib%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>matplotlib的安装 pip install -U pip setuptools pip install matplotlib matplotlib的使用 散点图：scatter 使用:</description>
    </item>
    
  </channel>
</rss>
